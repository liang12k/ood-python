
Roulette :class:Game
====================
:note: chicken-and-egg design problem between :class:Player & :class:Game
:TODO: deliverables needs :class:Player to be used
       eg: Passenger57 always bets on Black
       rework later for sophisticated hierarchy of players
       
Game overview
-------------
:class:Game responsibility is to cycle through various steps of game procedure
-active class that makes use of classes built so far
 class is longer or more complex methods
Roulette Game:
 :note: there are other procedures, this is for roulette
 -getting bets from player
 -spinning wheel
 -resolving bets
 
Single round of roulette
~~~~~~~~~~~~~~~~~~~~~~~~
1. place bets
   notify Player obj to create Bet objs (placing bets delegated by :class:Player)
   reduce Player obj's stake (amount) as part of creating Bet
2. spin wheel
   get next spin of :class:Wheel
   winning Bin obj (w); collection of individual :class:Outcome instances of winners
3. resolve all bets
   each Bet obj (b), placed by Player obj:
   a. winner: Bet 'b' Outcome is in winning Bin 'w'
      	      notify Player obj that Bet 'b' is winner, update Player obj's stake
   b. loser:  Bet 'b' Outcome is not in winning Bin 'w'
      	      notify Player obj that Bet 'b' is not a winner, update betting amount for next round

Matching algorithm
------------------
:class:Game has responsibility for matching (Bin & Table)
a. collection of Outcome objs in Bin obj of :class:Wheel
b. collection of Outcome objs of Bet objs on :class:Table
-- loop/nested loops to compare individual elements from these two collections

a. driven by Bin obj
   loop to visit each Outcome obj in winning Bin obj
   each Outcome obj visit each of Bet objs contained by :class:Table
   Bet obj's Outcome that matches Bin obj's Outcome is a winner and paid off
   other bets are losers
   :: nested loops
      a. one to visit winning Outcome objs of Bin obj
      b. one to visit Bet objs of :class:Table

b. driven by Table obj (alternative: visit each Bet obj contained by :class:Table)
   winning Bin obj has set of Outcome objs
   -exploit set membership methods to test for presence/absence of Bet obj's Outcome in winning Bin obj's set
    if Bin obj contains Oucome, Bin obj is a winner; else a loser
    :: single loop
       -visit Bet objs of :class:Table

Player interface
~~~~~~~~~~~~~~~~
:class:Game collaboratese with :class:Player
:note:'chicken-and-egg' problem in decomposing relationship between these classes
:class:Player is a complete hierarchy of subclasses
-each of which provides a different betting strategy (rework: craps, blackjack, etc.)
develop :class:Game unit tests with a stub for Player obj placing single kind of Bet
-'Passenger57': always bet on Black

:note: rework tbd for more sophisticated players
       (opt'l) addt'l roulette considerations for advance designing

Passenger57 design
------------------
:class:Passenger57
constructs a Bet obj based on Outcome named 'Black'; persistent player
-need a source for Black outcome
 several choices (see :class:Bet)
 query :class:Wheel for needed Outcome obj
-rework tbd:
 a. define :class:Player superclass
 b. make :class:Passenger57 a subclass of :class:Player

Fields
~~~~~~
Passenger57.black
outcome which player focuses their betting
-Player obj will get this from :class:Wheel using well-known bet name

Passenger57.table
Table obj used to place individual Bet objs

Constructors
~~~~~~~~~~~~
Passenger57.__init__(self,table)
constructs Player obj with specific table for placing bets
-creates 'Black' Outcome
Params:
	table (:class:Table): Table instance on which bets are placed

Methods
~~~~~~~
Passenger57.placeBets(self)
updates Table obj with various bets; places 'black' bet
-this version creates a Bet instance from 'black' Outcome

Passenger57.win(self,bet)
notification from :class:Game that the Bet obj was a winner
-amount of money won is available via .winAmount() method of .theBet
Params:
	bet (:class:Bet): bet which won

Passenger57.lose(self,bet)
notification from :class:Game that the Bet obj was a loser
Params:
	bet (:class:Bet): bet which lost

Roulette game design
--------------------
:class:Game
Game manages sequence of actions that define Roulette game
-includes:
 a. notifying Player obj to place bets
 b. spinning :class:Wheel
 c. resolving Bet objs actually present of :class:Table

Fields
~~~~~~

